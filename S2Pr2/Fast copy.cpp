/*Недостатком кода в файле является потенциальная возможность выхода за границы массива mas_a 
при копировании в массив mas_b, если размер массива mas_a превышает размер массива mas_b. 
Необходимо убедиться, что размер массива mas_a не больше размера массива mas_b перед копированием, 
либо использовать функции копирования, которые проверяют размеры массивов.*/

#include <iostream>
#include <string>
#include <sstream>
#include <vector>

// Позволяет обрабатывать данные либо по одному байту, либо по 8

enum mode
{
    Byte, Byte8
};

template <typename T> /*является параметром типа, который может быть заменен на любой
допустимый тип данных во время компиляции. Это позволяет создавать обобщенный код, 
который может работать с разными типами данных без необходимости повторного написания кода 
для каждого типа.*/

void copy(T* given, T* copied, uint64_t bytescount, mode Mode)
{
    /* Если режим копирования 1 байт, то происходит копирование байтов из одной области памяти
    в другую при помощи цикла, проходящего по каждому байту и копирующего его*/
    if (Mode == mode::Byte)
    {
        char* Fgiven = (char*)given;
        char* Scopied = (char*)copied;
        for (uint64_t i = 0; i < bytescount; i++)
        {
            Fgiven[i] = Scopied[i];
        }
    }
    /* Иначе div вычисляет количество 8 битных блоков, которые нужно скопировать
    Перменная mod считает остаток от деления количества байт на 8. 
    Если div отличен от нуля то происходит тот же цикл, что и сверху. Если
    mod  отличен от нуля то вызывается рекурсивно функция copy. Иначе, т.е если div 
    равен нулю, вызывается функция copy*/ 
    else 
    {
        uint64_t div = bytescount / 8;
        uint8_t mod = bytescount % 8;
        if (div > 0) {
            double* Fgiven = (double*)given;
            double* Scopied = (double*)copied;
            for (uint64_t i = 0; i < div; i++)
            {
                Fgiven[i] = Scopied[i];
            }
            if (mod != 0) 
            {
                copy(given + div, copied + div, mod, mode::Byte);
            }
        }
        else copy(given, copied, mod, mode::Byte);
    }
}

int main()
{

    int N[10] = { 1,2,3,4,5,6,7,8,9, 10 };
    int M[10];

    copy(M, N, sizeof(N), mode::Byte8);
    for (int i = 0; i < sizeof(N)/sizeof(int); ++i)
    {
        std::cout << M[i] << " ";
    }
}
/* Этот код эффективно копирует блоки памяти разных размеров(8 байт и меньше),
определяя, сколько элементов double можно скопировать за один раз, 
а затем используя рекурсивный вызов, если есть остаток, который необходимо 
скопировать с помощью байта в байтовом режиме. Это позволяет избежать дополнительного 
копирования и уменьшить накладные расходы на вызов функции. Также использование указателей 
на char для байтового копирования позволяет скопировать память более эффективно, 
т.к. char имеет меньший размер, чем тип, который копируется, и может быть более эффективно 
выровнен в памяти.*/